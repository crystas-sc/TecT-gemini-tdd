import {
	GoogleGenerativeAI,
	HarmCategory,
	HarmBlockThreshold,
	GenerativeModel,
} from "@google/generative-ai"


const MODEL_NAME = "gemini-1.0-pro";

let gemniniModel: GenerativeModel;

export const genUnitTests = async (acceptanceCriteria: string, testingFramework: string, apiKey: string) => {
	if (!gemniniModel) {
		const genAI = new GoogleGenerativeAI(apiKey);
		const model = genAI.getGenerativeModel({ model: MODEL_NAME });
		gemniniModel = model;
	}
	const generationConfig = {
		temperature: 0.7,
		topK: 1,
		topP: 1,
		maxOutputTokens: 2048,
	};

	const safetySettings = [
		{
			category: HarmCategory.HARM_CATEGORY_HARASSMENT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
	];

	const parts = [
		{ text: "input: create unit test cases for the following acceptance criteria using jest javascript library in the format of given when then\nThe UI component should allow users to visually build logical expressions using familiar logical operators such as AND, OR, and NOT.\nUsers should be able to drag and drop components to create and rearrange logical expressions effortlessly.\nThe UI should provide a clear indication of the current state of the logical expression being built, including highlighting errors or invalid configurations.\nUsers should have the ability to easily edit and modify existing logical expressions.\nThe UI component should support a variety of input methods, including text input, dropdown menus, checkboxes, and radio buttons, for building complex logical expressions.\nThe UI should provide real-time feedback or suggestions to users while they are constructing logical expressions to improve usability and prevent errors.\nThe UI component should be responsive and compatible with different screen sizes and devices.\nThe logical expressions created using the UI component should be easily serializable and usable within the application's backend or other components.\nThe UI should provide clear documentation or tooltips explaining the purpose and usage of each component and operator within the logical expression builder.\nThe UI component should adhere to design standards and guidelines established for the application or platform it is being developed for." },
		{ text: "output: describe('Logical Expression UI Component', () => {\n    let logicalExpressionComponent;\n\n    beforeEach(() => {\n        // Setup logic to initialize the UI component before each test\n        logicalExpressionComponent = new LogicalExpressionComponent();\n    });\n\n    test('Given logical operators AND, OR, and NOT, when building logical expressions, then should allow using these operators', () => {\n        // Test logic to check if the UI component allows using logical operators\n        // Given\n        const operators = ['AND', 'OR', 'NOT'];\n\n        // When\n        const supportedOperators = logicalExpressionComponent.getSupportedOperators();\n\n        // Then\n        expect(supportedOperators).toEqual(expect.arrayContaining(operators));\n    });\n\n    test('Given draggable components, when creating and rearranging logical expressions, then should support drag and drop functionality', () => {\n        // Test logic to check if the UI component supports drag and drop functionality\n        // Given\n        const draggableComponent = logicalExpressionComponent.createDraggableComponent();\n\n        // When\n        const isDraggable = draggableComponent.isDraggable();\n\n        // Then\n        expect(isDraggable).toBe(true);\n    });\n\n    test('Given a logical expression with errors, when building expressions, then should highlight errors', () => {\n        // Test logic to check if the UI component highlights errors\n        // Given\n        const invalidExpression = 'A AND'; // missing operand\n\n        // When\n        const isValid = logicalExpressionComponent.validateExpression(invalidExpression);\n\n        // Then\n        expect(isValid).toBe(false);\n    });\n\n    test('Given an existing logical expression, when editing and modifying it, then should update the expression correctly', () => {\n    // Test logic to check if the UI component allows editing and modifying existing expressions\n    // Given\n    const existingExpression = 'A AND B OR C';\n    const modifiedExpression = 'A AND (B OR C)'; // modified to include parentheses\n\n    // When\n    const updatedExpression = logicalExpressionComponent.editExpression(existingExpression, 'B OR C', '(B OR C)');\n\n    // Then\n    expect(updatedExpression).toBe(modifiedExpression);\n});\n\ntest('Given various input methods, when building logical expressions, then should support different input types', () => {\n    // Test logic to check if the UI component supports different input methods\n    // Given\n    const inputMethods = ['text input', 'dropdown menu', 'checkbox', 'radio button'];\n\n    // When\n    const supportedInputMethods = logicalExpressionComponent.getSupportedInputMethods();\n\n    // Then\n    expect(supportedInputMethods).toEqual(expect.arrayContaining(inputMethods));\n});\n\ntest('Given a partially constructed expression, when providing real-time feedback, then should suggest corrections or improvements', () => {\n    // Test logic to check if the UI component provides real-time feedback\n    // Given\n    const partialExpression = 'A AND'; // missing second operand\n\n    // When\n    const feedback = logicalExpressionComponent.provideFeedback(partialExpression);\n\n    // Then\n    expect(feedback).toContain('Missing second operand');\n});\n\ntest('Given different screen sizes and devices, when testing responsiveness, then should adapt UI layout accordingly', () => {\n    // Test logic to check if the UI component is responsive\n    // Given\n    const screenSize = 'mobile'; // example of a mobile screen size\n\n    // When\n    const isResponsive = logicalExpressionComponent.testResponsiveness(screenSize);\n\n    // Then\n    expect(isResponsive).toBe(true);\n});\n\ntest('Given a logical expression, when serializing it, then should produce a valid serial representation', () => {\n    // Test logic to check if the UI component serializes expressions correctly\n    // Given\n    const logicalExpression = 'A AND (B OR C)';\n\n    // When\n    const serializedExpression = logicalExpressionComponent.serializeExpression(logicalExpression);\n\n    // Then\n    expect(serializedExpression).toEqual(expect.any(String));\n});\n\ntest('Given tooltips or documentation, when accessing information, then should provide clear explanations of usage', () => {\n    // Test logic to check if the UI component provides tooltips or documentation\n    // Given\n    const component = 'AND';\n\n    // When\n    const tooltip = logicalExpressionComponent.getTooltip(component);\n\n    // Then\n    expect(tooltip).not.toBeUndefined();\n});\n\ntest('Given design standards, when testing adherence, then should meet established guidelines', () => {\n    // Test logic to check if the UI component adheres to design standards\n    // Given\n    const designStandards = ['consistency', 'accessibility', 'usability'];\n\n    // When\n    const adherence = logicalExpressionComponent.testDesignStandards(designStandards);\n\n    // Then\n    expect(adherence).toBe(true);\n});\n});" },
		{ text: "input: create \nunit test cases for the following acceptance criteria using jest \njavascript library in the format of given when then\nThe form UI should include input fields for entering the header \ninformation required for a Drools decision table, such as the package \nname, import statements, and table name.\nUsers should be able to input the package name in a designated field \nwithin the form UI.\nUsers should be able to add and manage multiple import statements in the\n form UI.\nThe form UI should allow users to enter the table name for the decision \ntable.\nUsers should be able to save the entered header information for later \nuse or modification.\nThe form UI should validate the input fields to ensure that required \ninformation is provided and in the correct format.\nUsers should receive clear error messages if any input field is left \nblank or contains invalid data.\nThe form UI should provide suggestions or auto-completion for commonly \nused import statements to improve user efficiency.\nUsers should have the ability to review and edit the entered header \ninformation before final submission.\nThe form UI should adhere to design standards and guidelines established\n for the application or platform it is being developed for, ensuring \nconsistency with the overall user interface.\nThe entered header information should be easily accessible and \nintegrable with other components or modules within the application \narchitecture.\nThe form UI should support responsive design principles to ensure \ncompatibility with various screen sizes and devices." },
		{ text: "output: describe('Drools Decision Table Header Form UI', () => {\n    let headerFormUI;\n\n    beforeEach(() => {\n        // Setup logic to initialize the form UI component before each test\n        headerFormUI = new DroolsDecisionTableHeaderForm();\n    });\n\n    test('Given the form UI, when initialized, then should include input fields for package name, import statements, and table name', () => {\n        // Test logic to check if the form UI includes required input fields\n        // Given\n        const expectedFields = ['package', 'importStatements', 'tableName'];\n\n        // When\n        const formFields = headerFormUI.getInputFields();\n\n        // Then\n        expect(formFields).toEqual(expect.arrayContaining(expectedFields));\n    });\n\n    test('Given the form UI, when inputting the package name, then should update the corresponding field', () => {\n        // Test logic to check if users can input the package name\n        // Given\n        const packageName = 'com.example.rules';\n\n        // When\n        headerFormUI.setInputValue('package', packageName);\n\n        // Then\n        expect(headerFormUI.getInputValue('package')).toBe(packageName);\n    });\n\n    test('Given the form UI, when managing import statements, then should allow adding and removing import statements', () => {\n        // Test logic to check if users can add and remove import statements\n        // Given\n        const importStatement = 'import com.example.model.*';\n\n        // When\n        headerFormUI.addImportStatement(importStatement);\n        const importedStatements = headerFormUI.getImportStatements();\n\n        // Then\n        expect(importedStatements).toContain(importStatement);\n\n        // Additional test case for removing import statement\n        headerFormUI.removeImportStatement(importStatement);\n        expect(headerFormUI.getImportStatements()).not.toContain(importStatement);\n    });\n\n    \n    test('Given the form UI, when inputting the table name, then should update the corresponding field', () => {\n        // Test logic to check if users can input the table name\n        // Given\n        const tableName = 'MyDecisionTable';\n\n        // When\n        headerFormUI.setInputValue('tableName', tableName);\n\n        // Then\n        expect(headerFormUI.getInputValue('tableName')).toBe(tableName);\n    });\n\n    test('Given the form UI, when saving entered header information, then should store it for later use', () => {\n        // Test logic to check if entered header information can be saved\n        // Given\n        const packageInfo = 'com.example.rules';\n        const importStatements = ['import com.example.model.*', 'import com.example.utils.*'];\n        const tableName = 'MyDecisionTable';\n\n        // When\n        headerFormUI.setInputValue('package', packageInfo);\n        importStatements.forEach(importStatement => headerFormUI.addImportStatement(importStatement));\n        headerFormUI.setInputValue('tableName', tableName);\n        headerFormUI.saveHeaderInformation();\n\n        // Then\n        const savedHeaderInfo = headerFormUI.getSavedHeaderInformation();\n        expect(savedHeaderInfo.package).toBe(packageInfo);\n        expect(savedHeaderInfo.importStatements).toEqual(importStatements);\n        expect(savedHeaderInfo.tableName).toBe(tableName);\n    });\n\n    test('Given the form UI, when validating input fields, then should return true if all required fields are filled and valid', () => {\n        // Test logic to check if input fields are validated correctly\n        // Given\n        const packageInfo = 'com.example.rules';\n        const importStatements = ['import com.example.model.*', 'import com.example.utils.*'];\n        const tableName = 'MyDecisionTable';\n\n        // When\n        headerFormUI.setInputValue('package', packageInfo);\n        importStatements.forEach(importStatement => headerFormUI.addImportStatement(importStatement));\n        headerFormUI.setInputValue('tableName', tableName);\n\n        // Then\n        expect(headerFormUI.validateInputFields()).toBe(true);\n    });\n\n    test('Given the form UI, when validating input fields, then should return false if any required field is blank or invalid', () => {\n        // Test logic to check if input fields are validated correctly\n        // Given\n        const packageInfo = ''; // blank package name\n        const importStatements = ['import com.example.model.*', 'import com.example.utils.*'];\n        const tableName = ''; // blank table name\n\n        // When\n        headerFormUI.setInputValue('package', packageInfo);\n        importStatements.forEach(importStatement => headerFormUI.addImportStatement(importStatement));\n        headerFormUI.setInputValue('tableName', tableName);\n\n        // Then\n        expect(headerFormUI.validateInputFields()).toBe(false);\n    });\n});" },
		{ text: "input: create unit test cases for the following acceptance criteria using jest javascript library in the format of given when thenThe form UI should include input fields for entering each row of data required for a Drools decision table, including conditions, actions, and metadata.Users should be able to add, remove, and rearrange rows in the form UI effortlessly.Each row in the form UI should contain input fields for entering condition columns, representing the conditions for firing rules in the decision table.Users should have the ability to input action columns in each row, representing the actions to be executed when the corresponding conditions are met.The form UI should allow users to specify metadata for each row, such as rule names, descriptions, and other relevant information.Users should be able to save the entered row information for later use or modification.The form UI should validate the input fields to ensure that required information is provided and in the correct format.Users should receive clear error messages if any input field is left blank or contains invalid data.The form UI should provide suggestions or auto-completion for commonly used values in condition and action columns to improve user efficiency.Users should have the ability to review and edit the entered row information before final submission.The form UI should adhere to design standards and guidelines established for the application or platform it is being developed for, ensuring consistency with the overall user interface.The entered row information should be easily accessible and integrable with other components or modules within the application architecture.The form UI should support responsive design principles to ensure compatibility with various screen sizes and devices." },
		{ text: "output: describe('Drools Decision Table Row Form UI', () => {\n    let rowFormUI;\n\n    beforeEach(() => {\n        // Setup logic to initialize the form UI component before each test\n        rowFormUI = new DroolsDecisionTableRowForm();\n    });\n\n    test('Given the form UI, when initialized, then should include input fields for conditions, actions, and metadata for each row', () => {\n        // Test logic to check if the form UI includes required input fields for each row\n        // Given\n        const expectedFields = ['conditions', 'actions', 'metadata'];\n\n        // When\n        const formFields = rowFormUI.getRowInputFields();\n\n        // Then\n        expect(formFields).toEqual(expect.arrayContaining(expectedFields));\n    });\n\n    test('Given the form UI, when adding, removing, or rearranging rows, then should update rows effortlessly', () => {\n        // Test logic to check if users can add, remove, and rearrange rows effortlessly\n        // Given\n        const initialRowCount = rowFormUI.getRowCount();\n\n        // When\n        rowFormUI.addRow();\n        const updatedRowCount = rowFormUI.getRowCount();\n\n        // Then\n        expect(updatedRowCount).toBe(initialRowCount + 1);\n\n        // Additional test case for removing row\n        rowFormUI.removeRow();\n        expect(rowFormUI.getRowCount()).toBe(initialRowCount);\n\n        // Additional test case for rearranging rows\n        const rowOrderBefore = rowFormUI.getRowOrder();\n        rowFormUI.rearrangeRows(1, 0); // Move row at index 1 to index 0\n        const rowOrderAfter = rowFormUI.getRowOrder();\n\n        // Then\n        expect(rowOrderAfter[0]).toBe(rowOrderBefore[1]);\n        expect(rowOrderAfter[1]).toBe(rowOrderBefore[0]);\n    });\n\n   test('Given the form UI, when saving entered row information, then should store it for later use', () => {\n        // Test logic to check if entered row information can be saved\n        // Given\n        const conditions = ['Age > 18', 'Country == \"US\"'];\n        const actions = ['Grant Visa', 'Send Welcome Email'];\n        const metadata = { ruleName: 'Grant Visa for US Residents', description: 'Welcome email sent for US residents above 18' };\n\n        // When\n        rowFormUI.setRowInputValue(0, 'conditions', conditions);\n        rowFormUI.setRowInputValue(0, 'actions', actions);\n        rowFormUI.setRowInputValue(0, 'metadata', metadata);\n        rowFormUI.saveRowInformation(0);\n\n        // Then\n        const savedRowInfo = rowFormUI.getSavedRowInformation(0);\n        expect(savedRowInfo.conditions).toEqual(conditions);\n        expect(savedRowInfo.actions).toEqual(actions);\n        expect(savedRowInfo.metadata).toEqual(metadata);\n    });\n\n    test('Given the form UI, when validating input fields, then should return true if all required fields are filled and valid', () => {\n        // Test logic to check if input fields are validated correctly\n        // Given\n        const conditions = ['Age > 18', 'Country == \"US\"'];\n        const actions = ['Grant Visa', 'Send Welcome Email'];\n        const metadata = { ruleName: 'Grant Visa for US Residents', description: 'Welcome email sent for US residents above 18' };\n\n        // When\n        rowFormUI.setRowInputValue(0, 'conditions', conditions);\n        rowFormUI.setRowInputValue(0, 'actions', actions);\n        rowFormUI.setRowInputValue(0, 'metadata', metadata);\n\n        // Then\n        expect(rowFormUI.validateRowInputFields(0)).toBe(true);\n    });\n\n    test('Given the form UI, when validating input fields, then should return false if any required field is blank or invalid', () => {\n        // Test logic to check if input fields are validated correctly\n        // Given\n        const conditions = ['Age > 18', '']; // blank action\n        const actions = ['Grant Visa', 'Send Welcome Email'];\n        const metadata = { ruleName: 'Grant Visa for US Residents', description: 'Welcome email sent for US residents above 18' };\n\n        // When\n        rowFormUI.setRowInputValue(0, 'conditions', conditions);\n        rowFormUI.setRowInputValue(0, 'actions', actions);\n        rowFormUI.setRowInputValue(0, 'metadata', metadata);\n\n        // Then\n        expect(rowFormUI.validateRowInputFields(0)).toBe(false);\n    });\n\n    test('Given the form UI, when providing suggestions for input fields, then should return suggested values', () => {\n        // Test logic to check if suggestions for input fields are provided correctly\n        // Given\n        const suggestedValues = ['Age > 18', 'Age <= 18', 'Country == \"US\"', 'Country == \"UK\"'];\n\n        // When\n        const suggestions = rowFormUI.getSuggestions('conditions');\n\n        // Then\n        expect(suggestions).toEqual(expect.arrayContaining(suggestedValues));\n    });\n\n});" },
		{ text: "input: create unit test cases for the following acceptance criteria using jest javascript library in the format of given when then\nThe spreadsheet view should visually represent the structure of a decision table, including header information and rows of data.\nUsers should be able to view and interact with both the header and rows in a tabular format similar to a spreadsheet.\nThe spreadsheet view should display the package name, import statements, and table name in the header section, clearly indicating their respective fields.\nUsers should be able to scroll horizontally and vertically to navigate through large decision tables efficiently.\nEach row in the spreadsheet view should display the conditions, actions, and metadata for the corresponding rule in the decision table.\nUsers should have the ability to resize columns and rows to adjust the view according to their preferences.\nThe spreadsheet view should support basic spreadsheet functionalities such as selecting cells, copying and pasting values, and undo/redo operations.\nUsers should be able to edit the contents of cells in the spreadsheet view to modify the decision table data.\nThe spreadsheet view should provide clear visual cues to indicate selected cells, active cell, and current editing status.\nUsers should have the option to switch between different views or modes, such as a read-only view and an editable view, depending on their requirements.\nThe spreadsheet view should support keyboard shortcuts for common actions to improve user productivity.\nUsers should have the ability to export the decision table data displayed in the spreadsheet view to different formats, such as CSV or Excel.\nThe spreadsheet view should adhere to design standards and guidelines established for the application or platform it is being developed for, ensuring consistency with the overall user interface.\nThe spreadsheet view should support responsive design principles to ensure compatibility with various screen sizes and devices." },
		{ text: "output: describe('Spreadsheet View for Decision Table', () => {\n    let spreadsheetView;\n\n    beforeEach(() => {\n        // Setup logic to initialize the spreadsheet view component before each test\n        spreadsheetView = new SpreadsheetView();\n    });\n\n    test('Given the spreadsheet view, when initialized, then should represent decision table structure including header information and rows of data', () => {\n        // Test logic to check if the spreadsheet view represents the decision table structure\n        // Given\n        const decisionTable = getDummyDecisionTable(); // function to generate a dummy decision table\n\n        // When\n        spreadsheetView.loadDecisionTable(decisionTable);\n\n        // Then\n        expect(spreadsheetView.isDecisionTableLoaded()).toBe(true);\n    });\n\n    test('Given the spreadsheet view, when loaded with a decision table, then users should be able to view and interact with both the header and rows', () => {\n        // Test logic to check if users can view and interact with the header and rows\n        // Given\n        const decisionTable = getDummyDecisionTable(); // function to generate a dummy decision table\n\n        // When\n        spreadsheetView.loadDecisionTable(decisionTable);\n\n        // Then\n        expect(spreadsheetView.getHeader()).toBeDefined();\n        expect(spreadsheetView.getRows()).toBeDefined();\n    });\n\n    test('Given the spreadsheet view, when loaded with a decision table, then should display package name, import statements, and table name in the header section', () => {\n        // Test logic to check if the header section displays package name, import statements, and table name\n        // Given\n        const decisionTable = getDummyDecisionTable(); // function to generate a dummy decision table\n\n        // When\n        spreadsheetView.loadDecisionTable(decisionTable);\n\n        // Then\n        expect(spreadsheetView.getHeader().packageName).toBeDefined();\n        expect(spreadsheetView.getHeader().importStatements).toBeDefined();\n        expect(spreadsheetView.getHeader().tableName).toBeDefined();\n    });\n\ntest('Given the spreadsheet view, when loaded with a decision table, then users should be able to scroll horizontally and vertically to navigate through large decision tables efficiently', () => {\n        // Test logic to check if users can scroll horizontally and vertically\n        // Given\n        const decisionTable = getLargeDummyDecisionTable(); // function to generate a large dummy decision table\n\n        // When\n        spreadsheetView.loadDecisionTable(decisionTable);\n\n        // Then\n        expect(spreadsheetView.canScrollHorizontally()).toBe(true);\n        expect(spreadsheetView.canScrollVertically()).toBe(true);\n    });\n\n    test('Given the spreadsheet view, when loaded with a decision table, then each row should display conditions, actions, and metadata for the corresponding rule', () => {\n        // Test logic to check if each row displays conditions, actions, and metadata\n        // Given\n        const decisionTable = getDummyDecisionTable(); // function to generate a dummy decision table\n\n        // When\n        spreadsheetView.loadDecisionTable(decisionTable);\n\n        // Then\n        expect(spreadsheetView.getRows()).toBeDefined();\n        expect(spreadsheetView.getRows().length).toBe(decisionTable.rows.length);\n        expect(spreadsheetView.getRows()[0].conditions).toBeDefined();\n        expect(spreadsheetView.getRows()[0].actions).toBeDefined();\n        expect(spreadsheetView.getRows()[0].metadata).toBeDefined();\n    });\n\n    test('Given the spreadsheet view, when resizing columns and rows, then should adjust the view according to user preferences', () => {\n        // Test logic to check if columns and rows can be resized\n        // Given\n        const initialColumnWidth = spreadsheetView.getColumnWidth(0);\n        const initialRowHeight = spreadsheetView.getRowHeight(0);\n        const newWidth = initialColumnWidth + 10;\n        const newRowHeight = initialRowHeight + 10;\n\n        // When\n        spreadsheetView.setColumnWidth(0, newWidth);\n        spreadsheetView.setRowHeight(0, newRowHeight);\n\n        // Then\n        expect(spreadsheetView.getColumnWidth(0)).toBe(newWidth);\n        expect(spreadsheetView.getRowHeight(0)).toBe(newRowHeight);\n    });\n});" },
		{ text: "input: create unit test cases for the following acceptance criteria using jest javascript library in the format of given when then\nThe decision table header form UI should include a section for creating logical expressions.\nUsers should be able to access the logical expression creator UI component within the decision table header form.\nThe logical expression creator UI component should seamlessly integrate with the decision table header form, allowing users to build logical expressions for conditions or other metadata.\nUsers should be able to visually build logical expressions using familiar logical operators such as AND, OR, and NOT within the decision table header form.\nThe integration should allow users to drag and drop components from the logical expression creator UI into the decision table header form effortlessly.\nThe logical expression creator UI component should provide real-time feedback or suggestions while users are constructing logical expressions within the decision table header form.\nUsers should have the ability to easily edit and modify logical expressions within the decision table header form.\nThe decision table header form should support a variety of input methods, including text input, dropdown menus, checkboxes, and radio buttons, for building complex logical expressions.\nThe integration should ensure that the entered logical expressions are serialized and easily usable within the decision table header form or other components.\nUsers should have access to clear documentation or tooltips explaining the purpose and usage of the integrated logical expression creator UI component within the decision table header form.\nThe integration should adhere to design standards and guidelines established for the application or platform it is being developed for, ensuring consistency with the overall user interface.\nThe decision table header form should remain responsive and compatible with different screen sizes and devices after integrating the logical expression creator UI component.\nThe integration should be easily maintainable and extendable, allowing for future enhancements or modifications to both the logical expression creator UI component and the decision table header form." },
		{ text: "output: describe('Integration of Logical Expression Creator UI with Decision Table Header Form', () => {\n    let decisionTableHeaderForm;\n    let logicalExpressionCreator;\n\n    beforeEach(() => {\n        // Setup logic to initialize the decision table header form and logical expression creator components before each test\n        decisionTableHeaderForm = new DecisionTableHeaderForm();\n        logicalExpressionCreator = new LogicalExpressionCreator();\n    });\n\n    test('Given the decision table header form UI, when initialized, then should include a section for creating logical expressions', () => {\n        // Test logic to check if the decision table header form includes a section for creating logical expressions\n        // Given\n        const logicalExpressionSection = decisionTableHeaderForm.getLogicalExpressionSection();\n\n        // Then\n        expect(logicalExpressionSection).toBeDefined();\n    });\n\n    test('Given the decision table header form UI, when initialized, then users should be able to access the logical expression creator UI component', () => {\n        // Test logic to check if users can access the logical expression creator UI component within the decision table header form\n        // Given\n        const logicalExpressionCreatorComponent = decisionTableHeaderForm.getLogicalExpressionCreator();\n\n        // Then\n        expect(logicalExpressionCreatorComponent).toBeDefined();\n    });\n\n    test('Given the logical expression creator UI component, when integrated with the decision table header form, then should seamlessly allow users to build logical expressions', () => {\n        // Test logic to check if the logical expression creator UI component seamlessly integrates with the decision table header form\n        // Given\n        const expression = 'Age > 18 AND Country == \"US\" OR (Gender == \"Female\" AND Occupation == \"Student\")';\n        decisionTableHeaderForm.integrateLogicalExpressionCreator(logicalExpressionCreator);\n\n        // When\n        decisionTableHeaderForm.setLogicalExpression(expression);\n\n        // Then\n        expect(decisionTableHeaderForm.getLogicalExpression()).toBe(expression);\n    });\n\n    \n    test('Given the decision table header form UI, when integrated with the logical expression creator, then should allow users to visually build logical expressions using familiar logical operators', () => {\n        // Test logic to check if users can visually build logical expressions using familiar logical operators\n        // Given\n        decisionTableHeaderForm.integrateLogicalExpressionCreator(logicalExpressionCreator);\n\n        // When\n        const operators = logicalExpressionCreator.getAvailableOperators();\n\n        // Then\n        expect(operators).toContain('AND');\n        expect(operators).toContain('OR');\n        expect(operators).toContain('NOT');\n    });\n\n    test('Given the logical expression creator UI component, when integrated with the decision table header form, then should allow users to drag and drop components effortlessly', () => {\n        // Test logic to check if users can drag and drop components effortlessly\n        // Given\n        decisionTableHeaderForm.integrateLogicalExpressionCreator(logicalExpressionCreator);\n\n        // When\n        const isDragAndDropEnabled = logicalExpressionCreator.isDragAndDropEnabled();\n\n        // Then\n        expect(isDragAndDropEnabled).toBe(true);\n    });\n\n    test('Given the logical expression creator UI component, when integrated with the decision table header form, then should provide real-time feedback or suggestions', () => {\n        // Test logic to check if the logical expression creator UI component provides real-time feedback or suggestions\n        // Given\n        decisionTableHeaderForm.integrateLogicalExpressionCreator(logicalExpressionCreator);\n\n        // When\n        const hasRealTimeFeedback = logicalExpressionCreator.hasRealTimeFeedback();\n\n        // Then\n        expect(hasRealTimeFeedback).toBe(true);\n    });\n});" },
		{ text: "input: create unit test cases for the following acceptance criteria using junit Java library in the format of given when then\nThe Maven library project should provide CRUD (Create, Read, Update, Delete) operations for managing decision table header data in a database.\nUsers should be able to easily integrate the Maven library project into their Java applications as a dependency.\nThe library should support multiple database management systems (DBMS) such as MySQL, PostgreSQL, Oracle, etc., for flexibility in deployment.\nUsers should be able to create new decision table headers and persist them to the database using the provided CRUD operations.\nThe library should provide methods for retrieving decision table headers from the database based on various criteria, such as by ID, name, or other attributes.\nUsers should have the ability to update existing decision table headers in the database using the provided CRUD operations.\nThe library should support deletion of decision table headers from the database, ensuring proper cascading or constraint handling to maintain data integrity.\nUsers should be able to perform basic validation on decision table headers before persisting them to the database to prevent invalid data entries.\nThe library should handle database connection management efficiently, including connection pooling and error handling to ensure reliability and performance.\nUsers should have access to clear documentation or guides explaining how to use the library, including setup instructions, API documentation, and example code snippets.\nThe library should adhere to best practices and coding standards for Java development, ensuring maintainability and readability of the codebase.\nUsers should be able to customize database configurations such as connection settings, table names, and column mappings to fit their specific database setup.\nThe Maven library project should include comprehensive unit tests to validate the functionality of CRUD operations and ensure code coverage.\nThe library should provide logging capabilities to enable debugging and monitoring of database operations for troubleshooting purposes.\nThe Maven library project should be versioned and released following semantic versioning principles to facilitate dependency management and upgrades in user projects." },
		{ text: "output: import static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.List;\n\npublic class DecisionTableHeaderCRUDTest {\n\n    private DecisionTableHeaderCRUD decisionTableHeaderCRUD;\n    private Connection connection;\n\n    @Before\n    public void setUp() throws SQLException {\n        // Setup logic to initialize the CRUD operations and establish database connection before each test\n        decisionTableHeaderCRUD = new DecisionTableHeaderCRUD();\n\n        // Establish connection to a test database\n        String url = \"jdbc:mysql://localhost:3306/test_db\";\n        String username = \"username\";\n        String password = \"password\";\n        connection = DriverManager.getConnection(url, username, password);\n    }\n\n    @Test\n    public void testCreateDecisionTableHeader() throws SQLException {\n        // Test logic to check if a new decision table header can be created and persisted to the database\n        // Given\n        DecisionTableHeader header = new DecisionTableHeader();\n        header.setName(\"Test Header\");\n        header.setDescription(\"Test Description\");\n\n        // When\n        int id = decisionTableHeaderCRUD.createDecisionTableHeader(connection, header);\n\n        // Then\n        assertTrue(id > 0);\n    }\n\n    @Test\n    public void testRetrieveDecisionTableHeaderById() throws SQLException {\n        // Test logic to check if a decision table header can be retrieved from the database by ID\n        // Given\n        int id = 1;\n\n        // When\n        DecisionTableHeader header = decisionTableHeaderCRUD.retrieveDecisionTableHeaderById(connection, id);\n\n        // Then\n        assertNotNull(header);\n    }\n\n    @Test\n    public void testUpdateDecisionTableHeader() throws SQLException {\n        // Test logic to check if an existing decision table header can be updated in the database\n        // Given\n        int id = 1;\n        DecisionTableHeader header = decisionTableHeaderCRUD.retrieveDecisionTableHeaderById(connection, id);\n        header.setDescription(\"Updated Description\");\n\n        // When\n        boolean updated = decisionTableHeaderCRUD.updateDecisionTableHeader(connection, header);\n\n        // Then\n        assertTrue(updated);\n    }\n\n    @Test\n    public void testDeleteDecisionTableHeader() throws SQLException {\n        // Test logic to check if a decision table header can be deleted from the database\n        // Given\n        int id = 1;\n\n        // When\n        boolean deleted = decisionTableHeaderCRUD.deleteDecisionTableHeader(connection, id);\n\n        // Then\n        assertTrue(deleted);\n    }\n\n    @Test\n    public void testRetrieveAllDecisionTableHeaders() throws SQLException {\n        // Test logic to check if all decision table headers can be retrieved from the database\n        // When\n        List" },
		{ text: "input: create unit test cases for the following acceptance criteria using junit Java library in the format of given when then\nThe Maven library project should offer CRUD (Create, Read, Update, Delete) operations for managing decision row values in a database.\nUsers should be able to easily integrate the Maven library project into their Java applications as a dependency.\nThe library should support multiple database management systems (DBMS) such as MySQL, PostgreSQL, Oracle, etc., for flexibility in deployment.\nUsers should be able to create new decision row values and persist them to the database using the provided CRUD operations.\nThe library should provide methods for retrieving decision row values from the database based on various criteria, such as by ID, decision table ID, row ID, or other attributes.\nUsers should have the ability to update existing decision row values in the database using the provided CRUD operations.\nThe library should support deletion of decision row values from the database, ensuring proper cascading or constraint handling to maintain data integrity.\nUsers should be able to perform basic validation on decision row values before persisting them to the database to prevent invalid data entries.\nThe library should handle database connection management efficiently, including connection pooling and error handling to ensure reliability and performance.\nUsers should have access to clear documentation or guides explaining how to use the library, including setup instructions, API documentation, and example code snippets.\nThe library should adhere to best practices and coding standards for Java development, ensuring maintainability and readability of the codebase.\nUsers should be able to customize database configurations such as connection settings, table names, and column mappings to fit their specific database setup.\nThe Maven library project should include comprehensive unit tests to validate the functionality of CRUD operations and ensure code coverage.\nThe library should provide logging capabilities to enable debugging and monitoring of database operations for troubleshooting purposes.\nThe Maven library project should be versioned and released following semantic versioning principles to facilitate dependency management and upgrades in user projects." },
		{ text: "output: import static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.List;\n\npublic class DecisionRowValueCRUDTest {\n\n    private DecisionRowValueCRUD decisionRowValueCRUD;\n    private Connection connection;\n\n    @Before\n    public void setUp() throws SQLException {\n        // Setup logic to initialize the CRUD operations and establish database connection before each test\n        decisionRowValueCRUD = new DecisionRowValueCRUD();\n\n        // Establish connection to a test database\n        String url = \"jdbc:mysql://localhost:3306/test_db\";\n        String username = \"username\";\n        String password = \"password\";\n        connection = DriverManager.getConnection(url, username, password);\n    }\n\n    @Test\n    public void testCreateDecisionRowValue() throws SQLException {\n        // Test logic to check if a new decision row value can be created and persisted to the database\n        // Given\n        DecisionRowValue rowValue = new DecisionRowValue();\n        rowValue.setValue(\"Test Value\");\n        rowValue.setDecisionTableId(1);\n\n        // When\n        int id = decisionRowValueCRUD.createDecisionRowValue(connection, rowValue);\n\n        // Then\n        assertTrue(id > 0);\n    }\n\n    @Test\n    public void testRetrieveDecisionRowValueById() throws SQLException {\n        // Test logic to check if a decision row value can be retrieved from the database by ID\n        // Given\n        int id = 1;\n\n        // When\n        DecisionRowValue rowValue = decisionRowValueCRUD.retrieveDecisionRowValueById(connection, id);\n\n        // Then\n        assertNotNull(rowValue);\n    }\n\n    @Test\n    public void testUpdateDecisionRowValue() throws SQLException {\n        // Test logic to check if an existing decision row value can be updated in the database\n        // Given\n        int id = 1;\n        DecisionRowValue rowValue = decisionRowValueCRUD.retrieveDecisionRowValueById(connection, id);\n        rowValue.setValue(\"Updated Value\");\n\n        // When\n        boolean updated = decisionRowValueCRUD.updateDecisionRowValue(connection, rowValue);\n\n        // Then\n        assertTrue(updated);\n    }\n\n    @Test\n    public void testDeleteDecisionRowValue() throws SQLException {\n        // Test logic to check if a decision row value can be deleted from the database\n        // Given\n        int id = 1;\n\n        // When\n        boolean deleted = decisionRowValueCRUD.deleteDecisionRowValue(connection, id);\n\n        // Then\n        assertTrue(deleted);\n    }\n\n @Test\n    public void testRetrieveDecisionRowValuesByDecisionTableId() throws SQLException {\n        // Test logic to check if decision row values can be retrieved from the database by decision table ID\n        // Given\n        int decisionTableId = 1;\n\n        // When\n        List" },
		{ text: "input: create unit test cases for the following acceptance criteria using junit Java library in the format of given when then\nThe library function should take decision table header and rows data stored in the database as input.\nUsers should be able to easily integrate the library function into their Java applications as a dependency.\nThe library function should dynamically generate a DRL file based on the provided decision table header and rows data.\nThe generated DRL file should contain Drools rules corresponding to the decision table rules represented by the rows data.\nUsers should have the ability to specify mapping rules between decision table columns and Drools rule attributes in the generated DRL file.\nThe library function should handle various types of decision table conditions and actions, such as simple conditions, nested conditions, and multiple actions per rule.\nUsers should be able to customize the format and structure of the generated DRL file, including rule templates, imports, and package declarations.\nThe generated DRL file should adhere to the syntax and semantics of the Drools Rule Language, ensuring compatibility with Drools rule engines.\nUsers should have access to clear documentation or guides explaining how to use the library function, including setup instructions, API documentation, and example code snippets.\nThe library function should adhere to best practices and coding standards for Java development, ensuring maintainability and readability of the codebase.\nUsers should be able to customize configuration parameters such as rule template files, output directory, and other settings to fit their specific requirements.\nThe library function should handle errors and exceptions gracefully, providing informative error messages and proper error handling mechanisms.\nUsers should be able to specify additional configurations or transformations on the decision table data before generating the DRL file, such as applying business rules or transformations.\nThe library function should support localization and internationalization of rule templates and generated DRL files for multi-language support.\nUsers should be able to test and validate the generated DRL file using automated testing frameworks or Drools rule engine validation tools.\nThe library function should be versioned and released following semantic versioning principles to facilitate dependency management and upgrades in user projects.\nUsers should have the ability to extend or customize the library function to accommodate specific business requirements or use cases." },
		{ text: "output: import static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.List;\n\npublic class DRLGeneratorTest {\n\n    private DRLGenerator drlGenerator;\n    private Connection connection;\n\n    @Before\n    public void setUp() throws SQLException {\n        // Setup logic to initialize the DRLGenerator and establish database connection before each test\n        drlGenerator = new DRLGenerator();\n\n        // Establish connection to a test database\n        String url = \"jdbc:mysql://localhost:3306/test_db\";\n        String username = \"username\";\n        String password = \"password\";\n        connection = DriverManager.getConnection(url, username, password);\n    }\n\n    @Test\n    public void testGenerateDRLFile() throws SQLException {\n        // Test logic to check if a DRL file can be generated based on decision table header and rows data\n        // Given\n        DecisionTableHeader header = new DecisionTableHeader();\n        header.setName(\"Test Header\");\n        header.setDescription(\"Test Description\");\n\n        // Retrieve decision rows from the database\n        List" },
		{ text: "input: create unit test cases for the following acceptance criteria using junit Java library in the format of given when then\nThe library function should accept JSON logical expressions as input.\nUsers should be able to easily integrate the library function into their Java applications as a dependency.\nThe library function should parse and interpret the JSON logical expressions to generate Drools when conditions.\nThe generated Drools when conditions should accurately represent the logic specified in the JSON expressions.\nUsers should have the ability to specify mappings between JSON operators and corresponding Drools operators.\nThe library function should handle various types of logical expressions, including simple expressions, nested expressions, and combinations of logical operators (AND, OR, NOT).\nUsers should be able to customize the format and structure of the JSON logical expressions, including the use of parentheses for grouping and precedence.\nThe generated Drools when conditions should adhere to the syntax and semantics of Drools, ensuring compatibility with Drools rule engines.\nUsers should have access to clear documentation or guides explaining how to use the library function, including setup instructions, API documentation, and example code snippets.\nThe library function should adhere to best practices and coding standards for Java development, ensuring maintainability and readability of the codebase.\nUsers should be able to customize configuration parameters such as operator mappings and parsing rules to fit their specific requirements.\nThe library function should handle errors and exceptions gracefully, providing informative error messages and proper error handling mechanisms.\nUsers should have the ability to specify additional configurations or transformations on the JSON expressions before interpreting them, such as applying business rules or transformations.\nThe library function should support localization and internationalization of JSON expressions for multi-language support.\nUsers should be able to test and validate the interpretation of JSON expressions using automated testing frameworks or Drools rule engine validation tools.\nThe library function should be versioned and released following semantic versioning principles to facilitate dependency management and upgrades in user projects.\nUsers should have the ability to extend or customize the library function to accommodate specific business requirements or use cases." },
		{ text: "output: import static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.util.Map;\n\npublic class JSONToDroolsInterpreterTest {\n\n    private JSONToDroolsInterpreter interpreter;\n\n    @Before\n    public void setUp() {\n        // Initialize the interpreter before each test\n        interpreter = new JSONToDroolsInterpreter();\n    }\n\n    @Test\n    public void testAcceptJSONInput() {\n        // Test logic to check if the interpreter accepts JSON logical expressions as input\n        // Given\n        String jsonExpression = \"{\\\"condition\\\": \\\"A AND (B OR C)\\\"}\";\n\n        // When\n        interpreter.parseJSONExpression(jsonExpression);\n\n        // Then\n        // No exceptions should be thrown\n        assertTrue(true);\n    }\n\n    @Test\n    public void testIntegrateIntoJavaApplication() {\n        // Test logic to check if the library function can be easily integrated into a Java application\n        // Given\n        // Integration setup in the Java application\n\n        // When\n        // Integration point where the interpreter is used\n\n        // Then\n        // Integration successfully completes without errors\n        assertTrue(true);\n    }\n\n    @Test\n    public void testParseAndInterpretJSONExpression() {\n        // Test logic to check if the interpreter parses and interprets JSON expressions correctly\n        // Given\n        String jsonExpression = \"{\\\"condition\\\": \\\"A AND (B OR C)\\\"}\";\n\n        // When\n        Map" },
		{ text: "input: create unit test cases for the following acceptance criteria using junit Java library in the format of given when then\nThe library function should provide a mechanism to load a DRL file from the file system.\nUsers should be able to easily integrate the library function into their Java applications as a dependency.\nThe library function should handle loading DRL files with Drools rules and configurations.\nUsers should have the ability to specify the path or location of the DRL file to be loaded.\nThe library function should validate the syntax and semantics of the loaded DRL file to ensure correctness.\nUsers should be able to access the loaded Drools rules and configurations programmatically.\nThe library function should support loading multiple DRL files and combining their contents, if necessary.\nUsers should have the option to reload the DRL file dynamically during runtime to reflect changes made externally.\nThe library function should handle errors and exceptions gracefully, providing informative error messages and proper error handling mechanisms.\nUsers should have access to clear documentation or guides explaining how to use the library function, including setup instructions, API documentation, and example code snippets.\nThe library function should adhere to best practices and coding standards for Java development, ensuring maintainability and readability of the codebase.\nUsers should be able to customize configuration parameters such as file path formats and validation rules to fit their specific requirements.\nThe library function should support different file formats, such as plain text DRL files or packaged DRL files within JAR archives.\nUsers should have the ability to test and validate the loading process using automated testing frameworks or validation tools.\nThe library function should be versioned and released following semantic versioning principles to facilitate dependency management and upgrades in user projects.\nUsers should have the ability to extend or customize the library function to accommodate specific business requirements or use cases." },
		{ text: "output: import static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.util.List;\nimport org.drools.compiler.kie.builder.impl.KieContainerImpl;\n\npublic class DRLFileLoaderTest {\n\n    private DRLFileLoader fileLoader;\n\n    @Before\n    public void setUp() {\n        // Initialize the file loader before each test\n        fileLoader = new DRLFileLoader();\n    }\n\n    @Test\n    public void testLoadDRLFileFromFileSystem() {\n        // Test logic to check if the file loader loads a DRL file from the file system\n        // Given\n        String filePath = \"path/to/drl/file.drl\";\n\n        // When\n        KieContainerImpl container = fileLoader.loadDRLFile(filePath);\n\n        // Then\n        assertNotNull(container);\n        // Additional assertions to verify the contents of the loaded DRL file if needed\n    }\n\n    @Test\n    public void testIntegrateIntoJavaApplication() {\n        // Test logic to check if the library function can be easily integrated into a Java application\n        // Given\n        // Integration setup in the Java application\n\n        // When\n        // Integration point where the file loader is used\n\n        // Then\n        // Integration successfully completes without errors\n        assertTrue(true);\n    }\n\n    @Test\n    public void testHandleErrorsAndExceptions() {\n        // Test logic to check if the file loader handles errors and exceptions gracefully\n        // Given\n        String invalidFilePath = \"invalid/path/to/drl/file.drl\";\n\n        // When\n        KieContainerImpl container = fileLoader.loadDRLFile(invalidFilePath);\n\n        // Then\n        assertNull(container);\n        // Additional assertions to verify error handling behavior if needed\n    }\n\n@Test\n    public void testValidateSyntaxAndSemantics() {\n        // Test logic to check if the file loader validates the syntax and semantics of the loaded DRL file\n        // Given\n        String validFilePath = \"path/to/valid/drl/file.drl\";\n        String invalidFilePath = \"path/to/invalid/drl/file.drl\";\n\n        // When\n        KieContainerImpl validContainer = fileLoader.loadDRLFile(validFilePath);\n        KieContainerImpl invalidContainer = fileLoader.loadDRLFile(invalidFilePath);\n\n        // Then\n        assertNotNull(validContainer);\n        assertNull(invalidContainer);\n        // Additional assertions to verify error handling if necessary\n    }\n\n    @Test\n    public void testReloadDRLFileDynamically() {\n        // Test logic to check if users have the option to reload the DRL file dynamically during runtime\n        // Given\n        String filePath = \"path/to/drl/file.drl\";\n\n        // When\n        KieContainerImpl initialContainer = fileLoader.loadDRLFile(filePath);\n        fileLoader.reloadDRLFile(filePath);\n        KieContainerImpl reloadedContainer = fileLoader.loadDRLFile(filePath);\n\n        // Then\n        assertNotNull(initialContainer);\n        assertNotNull(reloadedContainer);\n        // Additional assertions to verify that the contents of the reloaded DRL file are updated\n    }\n\n    @Test\n    public void testCustomizeConfigurationParameters() {\n        // Test logic to check if users can customize configuration parameters such as file path formats and validation rules\n        // Given\n        fileLoader.setFilePathFormat(\"custom/path/format\");\n        fileLoader.setValidateSyntax(false);\n\n        String filePath = \"custom/path/format/file.drl\";\n\n        // When\n        KieContainerImpl container = fileLoader.loadDRLFile(filePath);\n\n        // Then\n        assertNotNull(container);\n        // Additional assertions if necessary\n    }\n}" },
		{ text: `input: create unit test cases for the following acceptance criteria using ${testingFramework} in the format of given when then\n ${acceptanceCriteria}` },
		{ text: "output: " },
	];

	const result = await gemniniModel.generateContent({
		contents: [{ role: "user", parts }],
		generationConfig,
		safetySettings,
	});

	const response = result.response;
	const respText = response.text();

	console.log("respText", respText);
	return respText;

}


export const genUnitTestsFileName = async (acceptanceCriteria: string, testingFramework: string, apiKey: string) => {
	if (!gemniniModel) {
		const genAI = new GoogleGenerativeAI(apiKey);
		const model = genAI.getGenerativeModel({ model: MODEL_NAME });
		gemniniModel = model;
	}
	const generationConfig = {
		temperature: 1,
		topK: 1,
		topP: 1,
		maxOutputTokens: 2048,
	};

	const safetySettings = [
		{
			category: HarmCategory.HARM_CATEGORY_HARASSMENT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
	];

	const parts = [
		{ text: `input: create filename for storing acceptance criteria \n ${acceptanceCriteria}` },
		{ text: "output: " },
	];

	const result = await gemniniModel.generateContent({
		contents: [{ role: "user", parts }],
		generationConfig,
		safetySettings,
	});

	const response = result.response;
	const respText = response.text();

	console.log("respText", respText);
	
	// return respText?.match(/\*\*(.*?)\*\*/g)?.[0]?.replace(/\*/gi, "");
	return respText.replace(/\..*$/gi, "");

}


export const validateTestCodeAgainstAcceptCrit = async (acceptanceCriteria: string, testingFramework: string, code: string, apiKey: string) => {
	if (!gemniniModel) {
		const genAI = new GoogleGenerativeAI(apiKey);
		const model = genAI.getGenerativeModel({ model: MODEL_NAME });
		gemniniModel = model;
	}
	const generationConfig = {
		temperature: 1,
		topK: 1,
		topP: 1,
		maxOutputTokens: 2048,
	};

	const safetySettings = [
		{
			category: HarmCategory.HARM_CATEGORY_HARASSMENT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
	];

	const parts = [
		{ text: `input: Provide output in table with columns acceptance criteria and validated (true/false)
		 For the  source code provided below evaluate whether the source code validates the acceptance criteria :
		  ${acceptanceCriteria}
		 
		  source code :
		  ${code}
		  ` },
		{ text: "output: " },
	];

	const result = await gemniniModel.generateContent({
		contents: [{ role: "user", parts }],
		generationConfig,
		safetySettings,
	});

	const response = result.response;
	const respText = response.text();

	console.log("respText", respText);
	
	// return respText?.match(/\*\*(.*?)\*\*/g)?.[0]?.replace(/\*/gi, "");
	return respText.replace(/\..*$/gi, "");

}


export const genImplementationFromTestCode = async (code: string,  apiKey: string) => {
	if (!gemniniModel) {
		const genAI = new GoogleGenerativeAI(apiKey);
		const model = genAI.getGenerativeModel({ model: MODEL_NAME });
		gemniniModel = model;
	}
	const generationConfig = {
		temperature: 1,
		topK: 1,
		topP: 1,
		maxOutputTokens: 2048,
	};

	const safetySettings = [
		{
			category: HarmCategory.HARM_CATEGORY_HARASSMENT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
		{
			category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
			threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
		},
	];

	const parts = [
		{ text: `input: Generate mvc  implementation  for the below unit test code:

		Unit test code:
		  ${code}
		  ` },
		{ text: "output: " },
	];

	const result = await gemniniModel.generateContent({
		contents: [{ role: "user", parts }],
		generationConfig,
		safetySettings,
	});

	const response = result.response;
	const respText = response.text();

	console.log("respText", respText);
	
	// return respText?.match(/\*\*(.*?)\*\*/g)?.[0]?.replace(/\*/gi, "");
	return respText;

}